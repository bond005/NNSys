/*
   Copyright 2013-2014 Бондаренко Иван Юрьевич

   Этот файл — часть NNSys.

   NNSys - свободная программа: вы можете перераспространять её и/или изменять
её на условиях Стандартной общественной лицензии GNU в том виде, в каком она
была опубликована Фондом свободного программного обеспечения; либо версии 3
лицензии, либо (по вашему выбору) любой более поздней версии.

   NNSys распространяется в надежде, что она будет полезной, но БЕЗО ВСЯКИХ
ГАРАНТИЙ; даже без неявной гарантии ТОВАРНОГО ВИДА или ПРИГОДНОСТИ ДЛЯ
ОПРЕДЕЛЕННЫХ ЦЕЛЕЙ. Подробнее см. в Стандартной общественной лицензии GNU.

   Вы должны были получить копию Стандартной общественной лицензии GNU вместе с
этой программой. Если это не так, см. http://www.gnu.org/licenses/gpl.html.
*/

#ifndef TRAINER_UNIT_H
#define TRAINER_UNIT_H

#include <ctime>

#include <QObject>

#include "annlib.h"
#include "additional_unit.h"

class CTrainerForMLP: public QObject
{
    Q_OBJECT
public:
    CTrainerForMLP();
    ~CTrainerForMLP();

    /* Инициализировать алгоритм обучения с помощью списка ключей запуска
    rParams, сформированном путём анализа аргументов командной строки
    (см. описание функции parse_command_line).
       В случае успешной инициализации возвращается true, а в случае ошибки,
    вызванной указанием недопустимого ключа либо неверного значения допустимого
    ключа, - false. */
    bool initialize_params(const TCmdParams& rParams);

    /* Обучить нейросеть. Сама сеть и обучающее множество должны быть
    предварительно заданы (см. описание операции set_param). Остальные
    параметры алгоритма обучения также могут быть заданы перед вызовом
    операции train с помощью вышеупомянутой операции set_param (если
    они не были заданы, то используются значения по умолчанию).
       Если не задана обучаемая сеть либо обучающее множество, то функция
    возвращает false и выводит соответствующее сообщение об ошибке. Если
    всё нормально, то функция возвращает true. */
    bool do_training();
private:
    time_t m_TrainingStartTime;/* Время начала обучения */
    double m_TrainingDuration; /* Суммарное время, затраченное на работу с
                                  обучающим множеством (прямой и обратный
                                  проходы для всех примеров обучающего
                                  множества на каждой эпохе обучения) */
    double m_ControlDuration;  /* Суммарное время, затраченное на работу с
                                  контрольным множеством (вычисление ошибки
                                  обобщения после каждой эпохи обучения) */
    bool m_bCanTrain; /* Флаг, определяющий, можно ли запускать процесс
                         обучения с помощью метода train. Этот флаг
                         равен true, если все параметры алгоритма обучения
                         заданы правильно, и false - если хотя бы один
                         из параметров задан неправильно. */

    QString                 m_sTrainedNetFilename;/* имя файла с обучаемой
                                                     нейросетью. Нейросеть
                                                     будет сохраняться
                                                     туда после каждой эпохи
                                                     обучения */
    CMultilayerPerceptron   m_TrainedNet;         /* сама обучаемая сеть */
    CTrainingOfMLP          *m_pTrainingAlgorithm;/* алгоритм обучения */
    bool                    m_bEarlyStopping;     /* использовать ли критерий
                                                     раннего останова */
    int                     m_nEpochsCount;       /* количество выполненных
                                                     эпох обучения */
    bool                    m_bStoppedByCriterion;/* обучение завершено по
                                                     критерию раннего
                                                     останова? */
    bool                    m_bStoppedByGoal;     /* обучение завершено по
                                                     достижении заданной ошибки
                                                     обучения или обобщения */
    int                     m_nRestarts;          /* число рестартов
                                                     обучения */

    bool  m_bDoLogging;              /* надо ли вести протокол обучения? */
    bool  m_bShowTrainingError;      /* надо ли в протокол выводить ошибку
                                        обучения после каждой эпохи */
    bool  m_bShowGeneralizationError;/* надо ли в протокол выводить ошибку
                                        обобщения после каждой эпохи */

    float *m_aTrainInputs; /* обучающее множество: входные сигналы */
    float *m_aTrainTargets;/* обучающее множество: желаемые выходные сигналы */
    int m_nTrainSamples;   /* обучающее множествоЖ количество примеров */
    float *m_aControlInputs;   /* контрольное множество: входные сигналы */
    float *m_aControlTargets;  /* контрольное множество: желаемые выходные
                                  сигналы */
    int m_nControlSamples;     /* контрольное множествоЖ количество примеров */
    bool m_bControlSetIsLoaded;/* контрольное множество было загружено из
                                  файла, а не выделено из обучающего
                                  множества */

    float m_goalError; /* целевая ошибка (обучения или обобщения), при
                          достижении которой обучение пора прекращать (данный
                          критерий останова может комбинироваться с критерием
                          раннего останова) */

    float *m_aGeneralizationErrors;/* траектория ошибки обобщения */
    int    m_nMedfiltOrder;        /* порядок медианного фильтра для
                                      сглаживания траектории ошибки
                                      обобщения */
    float *m_aMedfiltBuffer;
    float m_oldMedian;

    float m_minError;

    /* Вычислить ошибку обобщения после m_nEpochsCount-й эпохи обучения */
    void calc_generalization_error();

    /* Проверить, выполняется ли критерий раннего останова (возвращается true)
    либо ещё не выполняется (возвращается false). */
    bool check_early_stopping();

    /* Поделить уже сформированное обучающее множество на два: собственно
    обучающее и контрольное (для проверки критерия раннего останова).
       Определение доли примеров, отведённых для контрольного множества,
    осуществляется на основе информации о числе свободных параметров обучаемой
    нейронной сети, поэтому нейросеть также должна быть уже загружена.
       Тем не менее, доля примеров контрольного множества должна составлять
    не менее 1% от общего числа примеров. */
    bool divide_between_train_and_control_sets();

    /* Поделить уже сформированное обучающее множество на два: собственно
    обучающее и контрольное (для проверки критерия раннего останова).
       Доля примеров, отведённых для контрольного множества, задаётся
    коэффициентом r. */
    bool divide_between_train_and_control_sets(const double& r);

    /* Пересчитать длительность обучения, добавив к текущему значению
    m_TrainingStartTime время, затраченное на в_полнение последней єпохи
    обучения. */
    void update_training_duration();
signals:
    /* Сигнал, информирующий алгоритм обучения о необходимости остановки. */
    void infoAboutTrainingStopping();
private slots:
    /* Выполнить инициализацию некоторых атрибутов перед началом обучения, а
    также занести в протокол обучения (если он ведётся) информацию о старте
    процесса обучения. */
    void start_training();

    /* Занести в протокол обучения (если он ведётся) информацию об окончании
    очередной эпохи обучения, а также проверить критерий раннего останова.
    Если в соответствии с этим критерием обучение необходимо останавливать,
    то алгоритму обучения посылается сигнал infoAboutTrainingStopping(). */
    void do_training_epoch(int nEpochsCount);

    /* Занести в протокол обучения (если он ведётся) информацию о завершении
    процесса обучения. */
    void end_training(TTrainingState state);
};

#endif // TRAINER_UNIT_H

